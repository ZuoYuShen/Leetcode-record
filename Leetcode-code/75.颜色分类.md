题目：
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。   

注意: 不能使用代码库中的排序函数来解决这道题。

示例：   

输入: [2,0,2,1,1,0]   
输出: [0,0,1,1,2,2]   

思路：荷兰国旗问题   

用一个指针p1表示数组中数字0的右边界，另一个指针p2表示数组中数字2的左边界。（初始化：p1 = 0, p2 = n-1）   

左边界：p1指向的数的前一个数是当前状态下，数组左边中数字中的最后一个0（左边全0）；右边界同理。   

设立遍历指针curr，初始化为0。（从左向右遍历）   

当nums[curr]==0时，说明此时0的右边界可以向右扩充。因此，交换nums[curr]和nums[p1]，同时p1可以向右移动一位。此时因为curr左边的值已经扫描过了，所以curr要++继续扫描下一位。   

当nums[curr]==2时，说明此时2的左边界可以向左扩充。因此，交换nums[curr]和nums[p2]，同时p2可以想左移动一位。此时与p2交换的值，curr未扫描，要停下来扫描一下，所以curr不用++。   

当nums[curr]==1时，因为不涉及到元素交换，因此p1，p2都不用移动，curr自然向右加一。

当curr > p2时，代表着划分完成（此时0和1全在curr左边）