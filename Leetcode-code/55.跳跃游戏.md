题目：   

给定一个非负整数数组，你最初位于数组的第一个位置。   
数组中的每个元素代表你在该位置可以跳跃的最大长度。   
判断你是否能够到达最后一个位置。   

Example：   

输入: [2,3,1,1,4]   
输出: true   
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。   

解题思路：基础DP，从后向前   

这一题的思路只要是“反过来想”，从终点出发，向起点进发。   
如果要能够到达终点，那么nums[n-1]>=1，如果满足，那么nums[n-1]就可以成为新的终点。（因为通过这个点可以到达最终的终点）   
如果不满足，就继续往前找，nums[n-2]>=2 ,..., nums[n-k]>=k，其中只要有满足的，就令该位置为“新的终点”。   
得到新的终点以后，向前遍历的思路和前面一样，仍然是寻找“前面有没有能够到达该终点的点”。   
遍历数组后，如果最后的“终点”是整个数组的起点，那么说明从数组起点可以到达数组终点。   
算是动态规划的题目吧。“找到前一个能够到达终点的点 ——> 更新终点”。   
优化方向的话，其实就是“找到满足条件的最前面的点作为新的终点”，就是说，也许当前的“终点”前面有很多可以到达该点的点，此时选择最前面的那一个作为状态更新的点（即下一个“终点”），可以加快速度。   