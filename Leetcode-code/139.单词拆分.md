题目：给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。  

说明：  

拆分时可以重复使用字典中的单词。  
你可以假设字典中没有重复的单词。  

Example：  
输入: s = "leetcode", wordDict = ["leet", "code"]   
输出: true   
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。   

思路：动态规划（如果用Set来存储单词表以提高查询效率的话，时间复杂度O(n^2)，空间复杂度为O(n)）  

定义dp[i]表示字符串s前i个字母组成的字符串s[0:i-1]是否能够被空格拆分成若干个字典中出现的单词。

从前往后计算考虑转移方程，每次转移的时候，需要枚举包含位置i-1的最后一个单词，看它是否出现在字典中以以及除去这部分的字符串是否合法即可。  

公式化的说，需要枚举s[0:i-1]中的分割点j，看s[0:j-1]组成的字符串s1（j=0时为空串）和s[j:i-1]组成的字符串s2是否都合法，如果都合法，说明s[0:i-1]合法。

由于计算到dp[i]时，已经计算除了dp[0:i-1]的值，因此s1是否合法可以直接由dp[j]得知，剩下只需要看s2是否合法。

因此转移方程为：

dp[i] = dp[j] && check(s[j:i-1])

其中，check(s[j:i-1])表示字符串s[j:i-1]是否出现在字典中。同时，j从0开始遍历到i-1，如果dp[j]和check(s[j:i-1])都为真，则可以跳出循环，因为此时s[0:i-1]已经可以被顺利拆分。

i从0开始，边界条件为：dp[0] = true。i从0开始遍历到s.size()。

最终，我们输出dp[s.size()]即可。（dp[s.size()]即表示整条字符串是否能合法拆分）