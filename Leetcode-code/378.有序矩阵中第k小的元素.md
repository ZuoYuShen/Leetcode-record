题目：给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。   
请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。   

Example：   

matrix = [   
   [ 1,  5,  9],   
   [10, 11, 13],   
   [12, 13, 15]   
],   
k = 8,   
   
返回 13。   


思路：   

1.暴力排序法（O(n^2logn)）   
把二维数组展平为一维数组，对一维数组进行排序后求出第k小的元素nums[k-1]。   

2.二分法   
由题目知，矩阵的最小值在matrix[0][0]，最大值在matrix[n-1][n-1]。根据行列元素的排序方式，可以知道，当给定一个数mid时，矩阵中可以画出一条分界线，分界线左上方的元素小于等于mid，右下方的元素大于mid。   

初始化L = matrix[0][0]， R = matrix[n-1][n-1]， mid = (L+R)/2。

因此从矩阵的左下角开始遍历数组，   

如果当前的matrix[i][j]<=mid，则可以知道这一列的前(i+1)个元素都 ≤ mid（下标从0开始），则此时用一个记录变量num，num += (i+1)。同时j++（向右走）   

如果当前的matrix[i][j]>mid，就向上走（i--）（向上走矩阵值会变小）   

如此遍历，指导i==0或j==n-1。

因此对于每个mid，只遍历了n个变量（i和j的移动次数加起来为n）

遍历完成后，得到num，因此在矩阵中，小于等于mid的数有num个。此时看num和k的大小关系，若num>=k，说明mid偏大，R=mid；若num小于k，说明mid偏小，L=mid+1。

因为在矩阵中，一定存在第k小的元素T，在mid小于该元素的情况下，num会一直小于k，而在mid大于该元素的情况下，num会一直大于等于k，因此L和R会不断地向T逼近，因此当L=R时，L=R=T。   

因此最后返回的L就是答案。   

时间复杂度：O(nlog(MAX-MIN))